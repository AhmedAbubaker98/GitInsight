# GitInsight Repository Analyzer

This README was generated by a sophisticated AI tool.
(This projec is still a work-in-progress)
![License: CC0](https://img.shields.io/badge/License-CC0-lightgrey.svg)
![Python Version](https://img.shields.io/badge/Python-3.11+-blue.svg)
![Framework: FastAPI](https://img.shields.io/badge/Framework-FastAPI-green.svg)
![Database: PostgreSQL](https://img.shields.io/badge/Database-PostgreSQL-blue.svg)
![Queue: Redis RQ](https://img.shields.io/badge/Queue-Redis%20RQ-red.svg)
![AI: Google Gemini](https://img.shields.io/badge/AI-Google%20Gemini-orange.svg)
![Docker: Yes](https://img.shields.io/badge/Docker-Yes-blue.svg)

## Table of Contents

- [Overview](#overview)
- [‚ú® Features](#-features)
- [üèóÔ∏è Architecture](#Ô∏è-architecture)
- [üõ†Ô∏è Tech Stack](#Ô∏è-tech-stack)
- [‚öôÔ∏è Setup and Installation](#Ô∏è-setup-and-installation)
- [üöÄ Running the Application](#-running-the-application)
- [üìñ Usage](#-usage)
- [üìù TODO](#-todo)
- [ü§ù Contributing](#-contributing)
- [üìÑ License](#-license)

## Overview

GitInsight is a multi-container web application designed to analyze GitHub repositories. It harnesses the power of Google's Gemini AI to generate insightful summaries, helping you quickly understand any codebase. The application supports both public and private repositories (with proper authentication) and provides a user-friendly web interface for initiating analyses, viewing results, and tracking your analysis history.

## ‚ú® Features

*   **AI-Powered Summaries:** Leverages Google Gemini for AI-driven analysis and summary generation.
*   **GitHub Repository Analysis:** Analyze both public and private GitHub repositories (with proper authentication using Authlib).
*   **Web Interface:** User-friendly UI for initiating analysis and viewing results.
*   **Analysis History:** Keeps track of past analyses for users.
*   **Asynchronous Task Processing:** Uses Redis RQ for efficient background processing of repository analysis.
*   **Microservice Architecture:** Modular design for scalability and maintainability.
*   **Persistent Data Storage:** Utilizes PostgreSQL for storing analysis history, user information, and analysis results.
*   **Dockerized:** Fully containerized with Docker and Docker Compose for easy deployment and environment consistency.

## üèóÔ∏è Architecture

The application follows a microservices architecture with the following components:

*   **API Service (FastAPI):** Handles user requests, manages analysis workflows, and interacts with the database.
*   **Repository Processor Service:** Clones repositories from GitHub, parses their content, and enqueues AI analysis tasks.
*   **AI Analyzer Service:** Processes AI analysis tasks using Google Gemini, generates summaries, and sends results back to the API.
*   **PostgreSQL Database:** Stores analysis history, user information, and analysis results.
*   **Redis with RQ:** Manages asynchronous tasks and ensures efficient processing of large numbers of repositories.

The services communicate via Redis queues. The API service receives requests, enqueues tasks to the repository processor, which then processes the repository and enqueues AI tasks. The AI analyzer processes these tasks and sends results to the API.

## üõ†Ô∏è Tech Stack

*   **Backend:** Python, FastAPI, SQLAlchemy, Asyncpg, Redis, RQ, GitPython, Google Generative AI, Authlib
*   **Frontend:** HTML, CSS, JavaScript (Vanilla JS)
*   **Database:** PostgreSQL
*   **Containerization:** Docker, Docker Compose

## ‚öôÔ∏è Setup and Installation

### Prerequisites

*   Python 3.11 (or compatible)
*   Git
*   Docker and Docker Compose

### Steps

1.  **Clone the repository:**
    ```bash
    git clone <your-repository-url>
    ```
2.  **Navigate to the project directory:**
    ```bash
    cd <project-directory-name>
    ```
3.  **Set up environment variables:**
    Create a `.env` file in the `app` directory (or the root, adjust as per your project structure) based on `.env.example` (if provided).
    ```bash
    # Example: cp app/.env.example app/.env
    ```
    This file should contain necessary configurations such as:
    *   Database credentials (PostgreSQL)
    *   Google Gemini API Key
    *   Redis connection details
    *   Secrets for authentication (Authlib)
    Ensure your services can access Redis and the database as configured.

4.  **Install dependencies (handled by Docker):**
    Dependencies for each service are listed in their respective `requirements.txt` files (e.g., `app/api_service/requirements.txt`). The Docker build process will automatically install these.
    If you need to install them manually for local development outside Docker:
    ```bash
    # Example for one service:
    # pip install -r app/api_service/requirements.txt
    # Repeat for other services as needed.
    ```

5.  **Build and run Docker containers:**
    Use Docker Compose to build and start all services:
    ```bash
    docker-compose up -d --build
    ```
    This command will build the images for all services and start them in detached mode.

## üöÄ Running the Application

After completing the setup and installation steps, the application services will be running via Docker Compose.

You can access the web interface at `http://localhost:8000` (or the appropriate address and port if you've changed the default FastAPI service port in your `docker-compose.yml`).

## üìñ Usage

1.  Open your web browser and navigate to the application's URL (e.g., `http://localhost:8000`).
2.  Use the web interface to submit a GitHub repository URL for analysis.
3.  If required, authenticate to analyze private repositories.
4.  View the AI-generated summary and other analysis results provided.
5.  Access your analysis history if this feature is implemented and you are logged in.

## üìù TODO

*   Tasks 
-- Rate limiting
-- more sophisticated Input sanitization
-- generating tests
-- (and more soon)

## ü§ù Contributing

Contributions are welcome! If you'd like to contribute, please follow these general steps:

1.  Fork the Project.
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`).
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`).
4.  Push to the Branch (`git push origin feature/AmazingFeature`).
5.  Open a Pull Request.

Please ensure your code adheres to the project's coding standards and that any relevant tests pass.

## üìÑ License

This project is licensed under the **CC0 1.0 Universal (CC0 1.0) Public Domain Dedication**. See the [LICENSE](LICENSE) file for more details (assuming a LICENSE file with CC0 details exists or will be added).